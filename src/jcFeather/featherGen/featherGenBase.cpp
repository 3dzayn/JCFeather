#include "featherGenBase.h"

featherGenBase::featherGenBase(){	
	_featherAttrs=NULL;
	init();
}
featherGenBase::~featherGenBase(){
	//do not do anything
}
void featherGenBase::init()
{
	initForEachFrame();
	_jcSysD.init();
	_multiThreadBarbNum = 50;

	setGlobalInfo("","","","");
	setCompressInfo(0,-1);

	_feaExpInf._userRender=featherExportInfo::DELIGHT;
	_feaExpInf.diceHair=false;
	_feaExpInf.exportNormal=false;
	_feaExpInf._frame=0;
	_feaExpInf._mbSample = 1;
	_feaExpInf._mbStep =1;
	_feaExpInf._mbFactor=1;
	_feaExpInf._mbCurrentSample = 0;
	_feaExpInf._proxyBB.clear();
	_feaExpInf._combineCacheContent = "";
	_feaExpInf._name="";
	_feaExpInf._allFiles.clear();
	_feaExpInf._localDir="";
	_feaExpInf._startTime=MTime(1,MTime::kFilm);

	_feaExpInf._useSelected =false;
	_feaExpInf._fileType=featherExportInfo::RIB;
	_feaExpInf._renderCurveFuncion=jcSpline::kCatmullRom;
	_feaExpInf._onlyGetBBox=false;
	_feaExpInf._filePostfix=".rib";
	_feaExpInf._featherAttrXmlIO.init();
	_feaExpInf._xmlFileBoundingbox.clear();
	_feaExpInf._jcFeatherNodes.clear();
	_feaExpInf._jcFeatherSysNodes.clear();
	_feaExpInf._jcFeatherNotIn.clear();

	_feaExpInf._renderAttr.init();
}
void featherGenBase::initForEachFrame()
{
	_feaExpInf._featherCacheIO.init();
}

void featherGenBase::setGlobalInfo(const MString &rRib,
							  const MString &meshRib,
							  const MString &constantBContent,
							  const MString &constRContent)
{
	_feaExpInf.featherRib = rRib;
	_feaExpInf.rachisMeshInsert = meshRib;
	_feaExpInf.constantParam = constantBContent;

	_feaExpInf.enableMotionBlur =false;

	_feaExpInf.comment = "##RenderMan RIB\n##Generated by jcFeather Jerry Kon";
}

//-----write feather file
bool featherGenBase::getBBFromMap(const string &str,MBoundingBox &bb)
{
	if(_feaExpInf._proxyBB.find(str)==_feaExpInf._proxyBB.end())
		return false;
	else
	{
		bb = _feaExpInf._proxyBB[str];
		return true;
	}
}

void featherGenBase::setCompressInfo(bool docomp,int level)
{
	_feaExpInf._compress.doCompress = docomp;
	_feaExpInf._compress.level = level;
}
bool featherGenBase::gzip( const char* inData, jcString &outData)
{
	uLong slen= (uLong)strlen(inData);

	z_stream zstr;
	zstr.zalloc = NULL;
	zstr.zfree = NULL;
	zstr.opaque = NULL;
	zstr.next_in = (Bytef*)inData;
	zstr.avail_in = slen;

	if(Z_OK != deflateInit2(&zstr, Z_DEFAULT_COMPRESSION, Z_DEFLATED, MAX_WBITS+16, 8, Z_DEFAULT_STRATEGY))
	{
		deflateEnd(&zstr);
		return false;
	}

	uLong dlen = deflateBound(&zstr, slen) + 12;
	if(!outData.getSpace(dlen))
	{
		deflateEnd(&zstr);
		return false;
	}

	zstr.avail_out = dlen;
	zstr.next_out = (Bytef*)outData._data;

	int ret = deflate(&zstr, Z_FINISH);
	assert(ret != Z_STREAM_ERROR);
	outData._length = zstr.total_out;

	deflateEnd(&zstr);

	return true;
}
bool featherGenBase::memMapWriteFile(const char *writeData,const char* path)
{
	if( _feaExpInf._compress.doCompress )
	{
		jcString dataToWrite;
		gzip(writeData,dataToWrite);
		jerryC::memoryMapWriteFile(path,dataToWrite._data,dataToWrite._length);
	}
	else
		jerryC::memoryMapWriteFile(path,writeData,0);

	return true;
}

//-----generate feather data
void featherGenBase::assignFeatherInfo(featherInfo *feaInfo)
{
	_featherAttrs = feaInfo;
}
void featherGenBase::getJCFeather( const MObject &inputSurface, singleFeather& oneFeather ,unsigned int seed)
{
	//clock_t t1,t2;
	//t1=clock();
	MStatus status=MS::kSuccess;

	seed += _featherAttrs->_randSeed;
	oneFeather.randSeed =  seed;//make each feahter different with id	

	MFnNurbsSurface surfaceFn;
	status = surfaceFn.setObject(inputSurface);
	lsysTurtle feaLsysTurtle;

	//rachis
	MPoint currentPt;
    float tempf=0;
	if(abs(_featherAttrs->_rachisEnd-_featherAttrs->_rachisStart)<0.00001) return;

	feaLsysTurtle.lsysInit(_featherAttrs->_rachisPos);
	moveInNurbs(_featherAttrs->_rachisStart,feaLsysTurtle);
	MFloatVector rachisNor;
	for(int ii=0;ii<_featherAttrs->_rachisSegment;++ii)
	{
		if(ii!=0)
			moveInNurbs( (_featherAttrs->_rachisEnd-_featherAttrs->_rachisStart)/(float)(_featherAttrs->_rachisSegment-1),feaLsysTurtle);
		if( _featherAttrs->_direction ==0 )
		{
			surfaceFn.getPointAtParam( feaLsysTurtle.currentPos.x,feaLsysTurtle.currentPos.z,currentPt,MSpace::kWorld );
			rachisNor = surfaceFn.normal(feaLsysTurtle.currentPos.x,feaLsysTurtle.currentPos.z,MSpace::kWorld,&status);
		}
		else
		{
			surfaceFn.getPointAtParam(feaLsysTurtle.currentPos.z,feaLsysTurtle.currentPos.x,currentPt,MSpace::kWorld);
			rachisNor = surfaceFn.normal(feaLsysTurtle.currentPos.z,feaLsysTurtle.currentPos.x,MSpace::kWorld,&status);
		}
		//add rachis point
		oneFeather.rachis.append( MFloatPoint(currentPt) );

		_featherAttrs->_rachisThickScale.getValueAtPosition((float)ii/(float)(_featherAttrs->_rachisSegment),
														tempf);
		oneFeather.rachisWidth.append( tempf*_featherAttrs->_rachisThick );
		oneFeather.rachisNormal.append(rachisNor);
	}
	getProxyBBFromRachis(oneFeather,1,0);
	if(_feaExpInf._onlyGetBBox) 
	{
		_feaExpInf._featherCacheIO._surfaces.addObject(inputSurface,oneFeather);
		return ;
	}

	//计算rachis长度
	for(unsigned int jj=0;jj<(oneFeather.rachis.length()-1);++jj)
		oneFeather.rachisLength+=(oneFeather.rachis[jj+1]-oneFeather.rachis[jj]).length();

	if( _featherAttrs->_rachisRenderAs == 1 || _featherAttrs->_outputFeatherMesh == 1)
		addCylinder(oneFeather);
	

	if( _featherAttrs->_barbuleLength<0.00001)return;
	//添加barbule的粗细数值
	for(int jj=0;jj<_featherAttrs->_barbuleSegments;++jj)
	{
		_featherAttrs->_barbuleThickScale.getValueAtPosition((float)jj/(float)_featherAttrs->_barbuleSegments,
																	tempf);
		oneFeather.barbuleWidth.append( tempf* _featherAttrs->_barbuleThick );
	}

	//--------------------------------
	vector<float> barbuleBarUpDownScale(_featherAttrs->_barbuleSegments);
	for(int jj=0;jj<_featherAttrs->_barbuleSegments;++jj)
		_featherAttrs->_barbuleUpDownScale.getValueAtPosition( (float)jj/(float)_featherAttrs->_barbuleSegments,
																	  barbuleBarUpDownScale[jj]);
	//----------------

	float currentForce=0,realAngle=0,realStep=0;
	int lr_n1_1=0;
	float thickRandNoise=0,lengthRandNoise=0,forceRandNoise=0,forceRs=0,forceS=0,thickAdj=1,updownR=0;
	float barbuleLength=0,barMaxLength=0,noRandomStep=0,uniformWidth=0,barbuleBarDensity=0,barbuleLengthScale=1;
	int   turnPoint = 0,lastTurn=0,currentTurn=0;
	bool  turnSwitch = true;

	MFloatPointArray singleBarbule;
	barbuleGapData gapData;
	MVector currentNormal;
	MFloatVectorArray barbuleNormal;

	for(int left_right=0;left_right<2;++left_right)
	{
		lr_n1_1 = left_right*2 - 1;

		if(!left_right)
		{
			if( _featherAttrs->_rachisPos > 0.9999f)	continue;
			else	barMaxLength = _featherAttrs->_barbuleLength * ( 1-_featherAttrs->_rachisPos );
		}
		else
		{
			if(_featherAttrs->_rachisPos < 0.0001f)	continue;
			else	barMaxLength = _featherAttrs->_barbuleLength * _featherAttrs->_rachisPos;
		}
		//-------get gap data
		computeGapData(gapData,left_right,seed);

		#pragma omp parallel for if( false &&jcFea_UseMultiThread && _featherAttrs->_barbuleNum>_multiThreadBarbNum) num_threads(jcFea_MaxThreads)\
			private(currentForce,realAngle,realStep)\
			private(thickRandNoise,lengthRandNoise,forceRandNoise,forceRs,forceS,thickAdj)\
			private(barbuleLength,noRandomStep,uniformWidth,barbuleBarDensity,barbuleLengthScale)\
			private(turnPoint,lastTurn,currentTurn,turnSwitch)\
			private(singleBarbule,currentNormal,currentPt,barbuleNormal,feaLsysTurtle)
		for(int ii=0;ii<=_featherAttrs->_barbuleNum;++ii)
		{
			//-----continue or not
			_featherAttrs->_barbuleDensity.getValueAtPosition(((float)ii/(float)_featherAttrs->_barbuleNum),
																		barbuleBarDensity);
			if( noiseRandom(left_right,ii,0,seed) > barbuleBarDensity)	continue;

			if(!left_right )			
				_featherAttrs->_leftBarbuleLengthScale.getValueAtPosition( ((float)ii/(float)_featherAttrs->_barbuleNum),
																		  barbuleLengthScale);
			else
				_featherAttrs->_rightBarbuleLengthScale.getValueAtPosition( ((float)ii/(float)_featherAttrs->_barbuleNum),
																				  barbuleLengthScale);
			if(barbuleLengthScale<0.00001)	continue;
			//-----continue or not

			//-------get turbulence data
			_featherAttrs->_forceRotateScale.getValueAtPosition( ((float)ii/(float)_featherAttrs->_barbuleNum),
																forceRs);
			_featherAttrs->_forceScale.getValueAtPosition( ((float)ii/(float)_featherAttrs->_barbuleNum),
																forceS);
			_featherAttrs->_barbuleUpDownRachis.getValueAtPosition( ((float)ii/(float)_featherAttrs->_barbuleNum),
																updownR);
			_featherAttrs->_barbuleThickAdjust.getValueAtPosition( ((float)ii/(float)_featherAttrs->_barbuleNum),
																thickAdj);
			//-------get turbulence data

			//---------get rotate real angle
			feaLsysTurtle.lsysInit( (float)ii/(float)_featherAttrs->_barbuleNum , _featherAttrs->_rachisPos );
			realAngle = _featherAttrs->_keyBarAttrs.getStartAngleAt( ((float)ii/(float)_featherAttrs->_barbuleNum) );
			rotate( lr_n1_1*realAngle,feaLsysTurtle);
			rotateForGap(gapData,!left_right,ii,feaLsysTurtle);//rotate to get gaps
			//----------get rotate real angle

			singleBarbule.clear();
			barbuleNormal.clear();
			currentForce=0;			barbuleLength=0;			turnPoint = 0;			lastTurn=currentTurn=0;			turnSwitch=true;
			thickRandNoise = noiseRandom(left_right,ii,1,seed+left_right)*_featherAttrs->_barbuleRandThick;
			lengthRandNoise = noiseRandom(left_right,ii,2,seed+left_right)*_featherAttrs->_barbuleLengthRandScale;
			noRandomStep = barMaxLength/(float)(_featherAttrs->_barbuleSegments-1) * barbuleLengthScale ;
			uniformWidth = (1-thickRandNoise) * thickAdj;

			for(int jj=0;jj<_featherAttrs->_barbuleSegments;++jj)
			{
				if(jj!=0)
				{
					realStep = noRandomStep* ( 1 -  lengthRandNoise);
					moveInNurbs(realStep,feaLsysTurtle);
					barbuleLength += realStep;

					currentTurn = (int)(barbuleLength/noRandomStep);
					if( currentTurn > lastTurn ) {turnPoint++;turnSwitch=true;}
					else turnSwitch=false;
					lastTurn = currentTurn;

				}
				//大形旋转
				if( turnSwitch )
				{
					realAngle = _featherAttrs->_keyBarAttrs.getAngleAt( (float)ii/(float)_featherAttrs->_barbuleNum,(float)turnPoint/(float)_featherAttrs->_barbuleSegments );
					rotate( -lr_n1_1 * realAngle ,feaLsysTurtle);
				}
				//随机旋转
				forceRandNoise = noiseRandom(left_right,ii,jj,seed+left_right)*_featherAttrs->_forcePerSegment;
				currentForce +=	forceRandNoise*forceS;
				if( currentForce > _featherAttrs->_turnForce )
				{
					rotate( lr_n1_1*_featherAttrs->_rotateLamda * forceRs *  chooseLR((float)ii/(float)_featherAttrs->_barbuleNum,(float)jj/(float)_featherAttrs->_barbuleSegments,seed+left_right),
							feaLsysTurtle);
					currentForce = 0;
				}
				//-----得到世界坐标位置
				if( _featherAttrs->_direction ==0 )
				{
					surfaceFn.getPointAtParam(feaLsysTurtle.currentPos.x,feaLsysTurtle.currentPos.z,currentPt,MSpace::kWorld);
					currentNormal = surfaceFn.normal(feaLsysTurtle.currentPos.x,feaLsysTurtle.currentPos.z,MSpace::kWorld).normal();
				}
				else
				{
					surfaceFn.getPointAtParam(feaLsysTurtle.currentPos.z,feaLsysTurtle.currentPos.x,currentPt,MSpace::kWorld);
					currentNormal = surfaceFn.normal(feaLsysTurtle.currentPos.z,feaLsysTurtle.currentPos.x,MSpace::kWorld).normal();
				}
				//-----上下移动
				barbuleNormal.append(MFloatVector(currentNormal));
				currentNormal *= barbuleBarUpDownScale[jj] *updownR*_featherAttrs->_upDownLamda ;
				if(_featherAttrs->_upDownNoise)
					currentNormal *=( chooseLR((float)ii/(float)_featherAttrs->_barbuleNum,0,left_right+seed+32)+1)/2.0f;
				currentPt += currentNormal;
				
				//----barbule粗细
				singleBarbule.append( MFloatPoint(currentPt) );
			}

			#pragma omp critical
			{
				if(left_right==0)
				{
					oneFeather.leftBarbules.push_back(singleBarbule);
					oneFeather.leftBarbuleRachisPos.append((float)ii/(float)_featherAttrs->_barbuleNum);
					oneFeather.leftBarbuleLenPer.append(barbuleLength/barMaxLength);
					oneFeather.leftBarbuleWidth.append(uniformWidth);
					oneFeather.leftBarbuleNormal.push_back(barbuleNormal);
				}
				else
				{
					oneFeather.rightBarbules.push_back(singleBarbule);
					oneFeather.rightBarbuleRachisPos.append((float)ii/(float)_featherAttrs->_barbuleNum + 1);
					oneFeather.rightBarbuleLenPer.append(barbuleLength/barMaxLength);
					oneFeather.rightBarbuleWidth.append(uniformWidth);
					oneFeather.rightBarbuleNormal.push_back(barbuleNormal);	
				}
			}
		}
	}
	//t2=clock();
	//MString info;
	//info +=jcFea_UseMultiThread;
	//info +=" ";
	//info +=jcFea_MaxThreads;
	//info +=" ";
	//info +=(double)(t2-t1);
	//MGlobal::displayInfo(info);
	if(_featherAttrs->_outputFeatherMesh )
		genMeshFromFeather(oneFeather);
}
bool featherGenBase::getJCFeather(turtles& featherTurtle,singleFeather &realFeather,unsigned int seed)
{
	if(featherTurtle._exMeshFea)
		return getTurtleExJCFeather( featherTurtle,realFeather,seed);
	else
		return getTurtleJCFeather( featherTurtle,realFeather,seed);
}
void featherGenBase::genMeshFromFeather(singleFeather &oneFeather)
{
	polyObj barbuleMesh;
	lsysTurtle curTurtle;

	//--------------------------------------------------left mesh
	int barsize=oneFeather.leftBarbules.size();

	#pragma omp parallel for if( jcFea_UseMultiThread && barsize>_multiThreadBarbNum) num_threads(jcFea_MaxThreads)\
													   private(curTurtle,barbuleMesh)
	for( int ii=0;ii<barsize;++ii)
	{
		barbuleMesh.init();

		for(int jj=0;jj<_featherAttrs->_barbuleSegments;++jj)
		{
			curTurtle.currentPos = oneFeather.leftBarbules[ii][jj];
			curTurtle.currentUp = oneFeather.leftBarbuleNormal[ii][jj];
			if(jj==_featherAttrs->_barbuleSegments-1) curTurtle.currentDir = (curTurtle.currentPos-oneFeather.leftBarbules[ii][jj-1]).normal();
			else curTurtle.currentDir = (oneFeather.leftBarbules[ii][jj+1]-curTurtle.currentPos).normal();

			addBarbuleFacePoint(     barbuleMesh,
									(float)jj/(float)(_featherAttrs->_barbuleSegments-1) * oneFeather.leftBarbuleLenPer[ii],
									(float)ii/(float)_featherAttrs->_barbuleNum,
									0.5f/(float)_featherAttrs->_barbuleNum,
									oneFeather.barbuleWidth[jj]*oneFeather.leftBarbuleWidth[ii],
									1,curTurtle);
		}
		makeBarbuleFace(barbuleMesh);

		#pragma omp critical
		{	oneFeather.barbuleFace.appendMesh(barbuleMesh); }
	}


	//------------------------------------------------------right mesh
	barsize=oneFeather.rightBarbules.size();
	#pragma omp parallel for if( jcFea_UseMultiThread && barsize>_multiThreadBarbNum) num_threads(jcFea_MaxThreads)\
													   private(curTurtle,barbuleMesh)
	for( int ii=0;ii<barsize;++ii)
	{
		barbuleMesh.init();
		for(int jj=0;jj<_featherAttrs->_barbuleSegments;++jj)
		{
			curTurtle.currentPos = oneFeather.rightBarbules[ii][jj];
			curTurtle.currentUp = oneFeather.rightBarbuleNormal[ii][jj];
			if(jj==_featherAttrs->_barbuleSegments-1) curTurtle.currentDir = (curTurtle.currentPos-oneFeather.rightBarbules[ii][jj-1]).normal();
			else curTurtle.currentDir = (oneFeather.rightBarbules[ii][jj+1]-curTurtle.currentPos).normal();

			addBarbuleFacePoint(    barbuleMesh,
									(float)jj/(float)(_featherAttrs->_barbuleSegments-1) * oneFeather.rightBarbuleLenPer[ii],
									(float)ii/(float)_featherAttrs->_barbuleNum,
									0.5f/(float)_featherAttrs->_barbuleNum,
									oneFeather.barbuleWidth[jj]*oneFeather.rightBarbuleWidth[ii],
									-1,curTurtle);
		}
		makeBarbuleFace(barbuleMesh);

		#pragma omp critical
		{ oneFeather.barbuleFace.appendMesh(barbuleMesh); }
	}
}
void featherGenBase::getFeatherRachis(turtles& featherTurtle,singleFeather &realFeather)
{
	int turtleKeySize= featherTurtle._turtles.size();
	if(_featherAttrs->_curveType==1)
	{
		int rachisSample=_featherAttrs->_rachisSegment;
		if(rachisSample<turtleKeySize)rachisSample=turtleKeySize;
		featherTools::getPosNormFromTurtles(featherTurtle,rachisSample,_feaExpInf._renderCurveFuncion,
											realFeather.rachis,realFeather.rachisNormal);
		for(unsigned int jj=0;jj<realFeather.rachis.length()-1;++jj)
			realFeather.rachisLength += (realFeather.rachis[jj+1]-realFeather.rachis[jj]).length();
	}
	else
		featherTurtle.getRachis(realFeather);

	int rachisLen=realFeather.rachis.length();
	realFeather.rachisWidth.setLength(rachisLen);
	for(int ii=0;ii<rachisLen;++ii)
	{
		_featherAttrs->_rachisThickScale.getValueAtPosition((float)ii/(float)rachisLen,
															realFeather.rachisWidth[ii]);
		realFeather.rachisWidth[ii] *=_featherAttrs->_rachisThick ;
	}
	if( _featherAttrs->_rachisRenderAs == 1 || _featherAttrs->_outputFeatherMesh )
		addCylinder(realFeather);
}
bool featherGenBase::getTurtleExJCFeather(turtles& featherTurtle,singleFeather &realFeather,unsigned int seed)
{
	//clock_t t1,t2;
	//t1=clock();
	MStatus status=MS::kSuccess;

	int turtleKeySize= featherTurtle._turtles.size();
	if( turtleKeySize<=0||
		featherTurtle._leftPoints.length()<=1||
		featherTurtle._rightPoints.length()<=1) return false;//如果turtle没有rachis点则返回。

	seed += _featherAttrs->_randSeed;
	realFeather.randSeed =  seed;//make each feahter different with id
	
	//-----------------------------------------------------------------------------------------
	getFeatherRachis(featherTurtle,realFeather);
	if(realFeather.rachisLength<0.00001f) { realFeather.clear();	return false; }
	
	//-----------------------------------------------------------------------------------------get bounding box
	getExProxyBB(featherTurtle,realFeather);
	if(_feaExpInf._onlyGetBBox ||
		_feaExpInf._fileType==featherExportInfo::CACHE||
		_feaExpInf._fileType==featherExportInfo::CACHE_MR||
		_feaExpInf._fileType==featherExportInfo::CACHE_RM
		) //only need boundingbox
	{
		_feaExpInf._featherCacheIO._turtlesG.addObject(featherTurtle,realFeather);
		return true;
	}

	if(_featherAttrs->_barbuleNum<=0||_featherAttrs->_barbuleLength<0.00001) return true;//如果没有barbule则返回


	//-----------------------------------------------------------------------------------------
	//barbule start
	//添加barbule的粗细数值 barbule updown
	realFeather.barbuleWidth.setLength(_featherAttrs->_barbuleSegments);
	vector<float> barbuleBarUpDownScale(_featherAttrs->_barbuleSegments);
	
	for(int jj=0;jj<_featherAttrs->_barbuleSegments;++jj)
	{
		_featherAttrs->_barbuleThickScale.getValueAtPosition((float)jj/(float)_featherAttrs->_barbuleSegments,
																 realFeather.barbuleWidth[jj]);
		realFeather.barbuleWidth[jj]*= _featherAttrs->_barbuleThick ;
		_featherAttrs->_barbuleUpDownScale.getValueAtPosition( (float)jj/(float)_featherAttrs->_barbuleSegments,
																	  barbuleBarUpDownScale[jj]);
	}

	//----------------------------------------------------------------------------get baruble root lsysTurtle and lots of ramp values
	jcSpline3D posSpline,norSpline,sideSplines[2];
	if(_featherAttrs->_curveType==1)
	{
		featherTools::getJCSplineTurtlesPos(featherTurtle,posSpline);
		featherTools::getJCSplineTurtlesNor(featherTurtle,norSpline);
	}
	featherTools::getJCSplineTurtlesSide(featherTurtle._leftPoints,sideSplines[0]);
	featherTools::getJCSplineTurtlesSide(featherTurtle._rightPoints,sideSplines[1]);	

	//-----------------------------------------------------------------------------------------
	float currentForce=0,realAngle=0,realStep=0,barbuleLength=0;
	int   turnPoint = 0,lastTurn=0,currentTurn=0;
	bool  turnSwitch = true;
	float noRandomStep=0,barbuleLengthScale=0,uniformWidth=1,barbuleBarDensity=0;
	int	  lr_n1_1=0;
	float updownDegree=0,thickRandNoise=0,lengthRandNoise=0,forceRandNoise=0,forceRs=0,forceS=0,updownR=0,thickAdj=1,sideDist=0;

	MFloatPointArray singleBarbule;
	MFloatVectorArray barbuleNormal;	
	MVector currentNormal;
	barbuleGapData gapData;
	lsysTurtle feaLsysTurtle;
	MPoint sidePoint;

	for(int left_right=0;left_right<2;++left_right)
	{
		lr_n1_1 = 1-left_right*2;
		//-------get gap data
		computeGapData(gapData,left_right,seed);

		#pragma omp parallel for if( jcFea_UseMultiThread && _featherAttrs->_barbuleNum>_multiThreadBarbNum ) num_threads(jcFea_MaxThreads)\
					private(currentForce,realAngle,realStep,barbuleLength)\
					private(turnPoint,lastTurn,currentTurn,turnSwitch,noRandomStep,barbuleLengthScale,uniformWidth,barbuleBarDensity)\
					private(updownDegree,thickRandNoise,lengthRandNoise,forceRandNoise,forceRs,forceS,updownR,thickAdj,sideDist)\
					private(singleBarbule,barbuleNormal,currentNormal,feaLsysTurtle,sidePoint)
		for(int ii=0;ii<=_featherAttrs->_barbuleNum;++ii)
		{	
			//-----continue or not
			_featherAttrs->_barbuleDensity.getValueAtPosition(((float)ii/(float)_featherAttrs->_barbuleNum),
																		barbuleBarDensity);
			if( noiseRandom(left_right,ii,0,seed) > barbuleBarDensity)	continue;

			if(!left_right )			
				_featherAttrs->_leftBarbuleLengthScale.getValueAtPosition( ((float)ii/(float)_featherAttrs->_barbuleNum),
																		  barbuleLengthScale);
			else
				_featherAttrs->_rightBarbuleLengthScale.getValueAtPosition( ((float)ii/(float)_featherAttrs->_barbuleNum),
																				  barbuleLengthScale);
			if(barbuleLengthScale<0.00001)	continue;
			//-----continue or not

			//-------get current turtle
			if(_featherAttrs->_curveType==1)
				featherTools::getlsysTurtleFromSpline(_feaExpInf._renderCurveFuncion,ii,_featherAttrs->_barbuleNum,posSpline,norSpline,feaLsysTurtle);
			else
				featherTurtle.getPosition(feaLsysTurtle,(float)ii/(float)_featherAttrs->_barbuleNum );
			//-------get current turtle

			//-------get currentSidePt
			sideSplines[left_right].getValueAt( jcSpline::kBSpline,
												(double)ii/(double)_featherAttrs->_barbuleNum,
												&sidePoint.x,&sidePoint.y,&sidePoint.z);
			sideDist = feaLsysTurtle.currentPos.distanceTo(MFloatPoint(sidePoint));
			if(sideDist<0.00001) continue;
			//-------get currentSidePt


			//-------get turbulence data
			_featherAttrs->_forceRotateScale.getValueAtPosition( ((float)ii/(float)_featherAttrs->_barbuleNum),
																forceRs);
			_featherAttrs->_forceScale.getValueAtPosition( ((float)ii/(float)_featherAttrs->_barbuleNum),
																forceS);
			_featherAttrs->_barbuleUpDownRachis.getValueAtPosition( ((float)ii/(float)_featherAttrs->_barbuleNum),
																updownR);
			_featherAttrs->_barbuleThickAdjust.getValueAtPosition( ((float)ii/(float)_featherAttrs->_barbuleNum),
																thickAdj);
			//-------get turbulence data

			//---------get rotate real angle
			rotate(sidePoint,feaLsysTurtle);//rotate to the point direction
			realAngle = _featherAttrs->_keyBarAttrs.getStartAngleAt( ((float)ii/(float)_featherAttrs->_barbuleNum) );
			rotate( lr_n1_1*realAngle,feaLsysTurtle);
			rotateForGap(gapData,left_right,ii,feaLsysTurtle);//rotate to get gaps
			//----------get rotate real angle

			currentForce=0;		barbuleLength=0;		turnPoint = 0;		lastTurn=currentTurn=0;		turnSwitch=true;
			thickRandNoise = noiseRandom(left_right,ii,1,seed+left_right)*_featherAttrs->_barbuleRandThick;
			lengthRandNoise = noiseRandom(left_right,ii,2,seed+left_right)*_featherAttrs->_barbuleLengthRandScale;
			noRandomStep = _featherAttrs->_barbuleLength/(float)(_featherAttrs->_barbuleSegments-1) * 
																barbuleLengthScale *
																sideDist;
			uniformWidth = (1-thickRandNoise) * thickAdj;

			singleBarbule.clear();
			barbuleNormal.clear();
			
			for(int jj=0;jj<_featherAttrs->_barbuleSegments;++jj)
			{
				if(jj!=0)
				{
					realStep= noRandomStep * ( 1 - lengthRandNoise );
					move(realStep,feaLsysTurtle);
					barbuleLength += realStep;

					currentTurn = (int)(barbuleLength/noRandomStep);
					if( currentTurn > lastTurn ) {turnPoint++;turnSwitch=true;}
					else turnSwitch=false;
					lastTurn = currentTurn;
				}
				//大形旋转
				if( turnSwitch )
				{
					realAngle = _featherAttrs->_keyBarAttrs.getAngleAt( (float)ii/(float)_featherAttrs->_barbuleNum,(float)turnPoint/(float)_featherAttrs->_barbuleSegments);
					rotate( -realAngle * lr_n1_1,feaLsysTurtle);
				}
				//随机旋转
				forceRandNoise = noiseRandom(left_right,ii,jj,seed+left_right)*_featherAttrs->_forcePerSegment;
				currentForce +=	forceRandNoise*forceS;
				if( currentForce > _featherAttrs->_turnForce )
				{
					rotate( lr_n1_1* -_featherAttrs->_rotateLamda * forceRs * chooseLR((float)ii/(float)_featherAttrs->_barbuleNum,
							(float)jj/(float)_featherAttrs->_barbuleSegments,
							seed+left_right) ,feaLsysTurtle);
					currentForce = 0;
				}
				//上下移动
				updownDegree = barbuleBarUpDownScale[jj] *updownR* _featherAttrs->_upDownLamda ;
				if(_featherAttrs->_upDownNoise)
					updownDegree *= (chooseLR(  (float)ii/(float)_featherAttrs->_barbuleNum,
												(float)jj/(float)_featherAttrs->_barbuleSegments,
												seed+left_right)+1)/2.0f;

				rotateAlongRight(updownDegree,feaLsysTurtle);

				singleBarbule.append(feaLsysTurtle.currentPos);
				barbuleNormal.append(feaLsysTurtle.currentUp);
			}

			#pragma omp critical
			{
				if(left_right==0)
				{
					realFeather.leftBarbules.push_back(singleBarbule);
					realFeather.leftBarbuleRachisPos.append((float)ii/(float)_featherAttrs->_barbuleNum);
					realFeather.leftBarbuleLenPer.append(barbuleLength);
					realFeather.leftBarbuleWidth.append(uniformWidth);
					realFeather.leftBarbuleNormal.push_back(barbuleNormal);
				}
				else
				{
					realFeather.rightBarbules.push_back(singleBarbule);
					realFeather.rightBarbuleRachisPos.append( (float)ii/(float)_featherAttrs->_barbuleNum + 1 );
					realFeather.rightBarbuleLenPer.append(barbuleLength);
					realFeather.rightBarbuleWidth.append(uniformWidth);
					realFeather.rightBarbuleNormal.push_back(barbuleNormal);
				}
			}				
			singleBarbule.clear();
			barbuleNormal.clear();
		}
	}//-------left_right

	//---------计算长度的百分比
	float maxLenBar=-100;
	#pragma omp parallel sections if( jcFea_UseMultiThread ) num_threads(2) private(maxLenBar)
	{
		#pragma omp  section
		{
			maxLenBar=-100;
			for(int ii=0;ii<(int)realFeather.leftBarbuleLenPer.length();++ii) 
				if(realFeather.leftBarbuleLenPer[ii]>maxLenBar) maxLenBar=realFeather.leftBarbuleLenPer[ii];
			for(int ii=0;ii<(int)realFeather.leftBarbuleLenPer.length();++ii) 
				realFeather.leftBarbuleLenPer[ii] = realFeather.leftBarbuleLenPer[ii]/maxLenBar;
		}
		#pragma omp  section
		{	
			maxLenBar=-100;
			for(int ii=0;ii<(int)realFeather.rightBarbuleLenPer.length();++ii) 
				if(realFeather.rightBarbuleLenPer[ii]>maxLenBar) maxLenBar=realFeather.rightBarbuleLenPer[ii];
			for(int ii=0;ii<(int)realFeather.rightBarbuleLenPer.length();++ii) 
				realFeather.rightBarbuleLenPer[ii] = realFeather.rightBarbuleLenPer[ii]/maxLenBar;
		}
	}
	if(_featherAttrs->_outputFeatherMesh )
		genMeshFromFeather(realFeather);

	//t2=clock();
	//MString info;
	//info +=jcFea_UseMultiThread;
	//info +=" ";
	//info +=jcFea_MaxThreads;
	//info +=" ";
	//info +=(double)(t2-t1);
	//MGlobal::displayInfo(info);

	return true;
}
bool featherGenBase::getTurtleJCFeather( turtles& featherTurtle,singleFeather &realFeather,unsigned int seed)
{

	//clock_t t1,t2;
	//t1=clock();
	MStatus status=MS::kSuccess;

	int turtleKeySize= featherTurtle._turtles.size();
	if(turtleKeySize<=0) return false;//如果turtle没有rachis点则返回。

	seed += _featherAttrs->_randSeed;
	realFeather.randSeed =  seed;//make each feahter different with id
	
	//-----------------------------------------------------------------------------------------
	getFeatherRachis(featherTurtle,realFeather);
	if(realFeather.rachisLength<0.00001f) { realFeather.clear();	return false; }
	
	//-----------------------------------------------------------------------------------------
	float barMaxLength=0;
	barMaxLength = _featherAttrs->_barbuleLength * realFeather.rachisLength;//将barbule长度和rachis长度关联起来这样可以做到整体缩放
	getProxyBBFromRachis(realFeather,1.0,barMaxLength);//得到proxyboudingbox
	if( _feaExpInf._onlyGetBBox ||
		_feaExpInf._fileType==featherExportInfo::CACHE||
		_feaExpInf._fileType==featherExportInfo::CACHE_MR||
		_feaExpInf._fileType==featherExportInfo::CACHE_RM) //only need boundingbox
	{
		_feaExpInf._featherCacheIO._turtlesG.addObject(featherTurtle,realFeather);
		return true;
	}

	if(_featherAttrs->_barbuleNum<=0||_featherAttrs->_barbuleLength<0.00001) return true;//如果没有barbule则返回


	//-----------------------------------------------------------------------------------------
	//barbule start
	//添加barbule的粗细数值 barbule updown
	realFeather.barbuleWidth.setLength(_featherAttrs->_barbuleSegments);
	vector<float> barbuleBarUpDownScale(_featherAttrs->_barbuleSegments);
	
	for(int jj=0;jj<_featherAttrs->_barbuleSegments;++jj)
	{
		_featherAttrs->_barbuleThickScale.getValueAtPosition((float)jj/(float)_featherAttrs->_barbuleSegments,
																 realFeather.barbuleWidth[jj]);
		realFeather.barbuleWidth[jj]*= _featherAttrs->_barbuleThick ;
		_featherAttrs->_barbuleUpDownScale.getValueAtPosition( (float)jj/(float)_featherAttrs->_barbuleSegments,
																	  barbuleBarUpDownScale[jj]);
	}

	//----------------------------------------------------------------------------get baruble root lsysTurtle and lots of ramp values
	jcSpline3D posSpline,norSpline;
	if(_featherAttrs->_curveType==1)
	{
		featherTools::getJCSplineTurtlesPos(featherTurtle,posSpline);
		featherTools::getJCSplineTurtlesNor(featherTurtle,norSpline);
	}
	
	//-----------------------------------------------------------------------------------------
	float currentForce=0,realAngle=0,realStep=0,barbuleLength=0;
	int   turnPoint = 0,lastTurn=0,currentTurn=0;
	bool  turnSwitch = true;
	float noRandomStep=0,barbuleLengthScale=0,uniformWidth=1,barbuleBarDensity=0;
	int	  lr_n1_1=0;
	float updownDegree=0,thickRandNoise=0,lengthRandNoise=0,forceRandNoise=0,forceRs=0,forceS=0,updownR=0,thickAdj=1;

	MFloatPointArray singleBarbule;
	MFloatVectorArray barbuleNormal;	
	MVector currentNormal;
	barbuleGapData gapData;
	lsysTurtle feaLsysTurtle;

	for(int left_right=0;left_right<2;++left_right)
	{
		lr_n1_1 = 1-left_right*2;

		//-------get gap data
		computeGapData(gapData,left_right,seed);
		//-------get gapNoise value

		#pragma omp parallel for if( jcFea_UseMultiThread && _featherAttrs->_barbuleNum>_multiThreadBarbNum ) num_threads(jcFea_MaxThreads)\
					private(currentForce,realAngle,realStep,barbuleLength)\
					private(turnPoint,lastTurn,currentTurn,turnSwitch,noRandomStep,barbuleLengthScale,uniformWidth,barbuleBarDensity)\
					private(updownDegree,thickRandNoise,lengthRandNoise,forceRandNoise,forceRs,forceS,updownR,thickAdj)\
					private(singleBarbule,barbuleNormal,currentNormal,feaLsysTurtle)
		for(int ii=0;ii<=_featherAttrs->_barbuleNum;++ii)
		{	
			//-----continue or not
			_featherAttrs->_barbuleDensity.getValueAtPosition(((float)ii/(float)_featherAttrs->_barbuleNum),
																		barbuleBarDensity);
			if( noiseRandom(left_right,ii,0,seed) > barbuleBarDensity)	continue;

			if(!left_right )			
				_featherAttrs->_leftBarbuleLengthScale.getValueAtPosition( ((float)ii/(float)_featherAttrs->_barbuleNum),
																		  barbuleLengthScale);
			else
				_featherAttrs->_rightBarbuleLengthScale.getValueAtPosition( ((float)ii/(float)_featherAttrs->_barbuleNum),
																				  barbuleLengthScale);
			if(barbuleLengthScale<0.00001)	continue;
			//-----continue or not

			//-------get current turtle
			if(_featherAttrs->_curveType==1)
				featherTools::getlsysTurtleFromSpline(_feaExpInf._renderCurveFuncion,ii,_featherAttrs->_barbuleNum,posSpline,norSpline,feaLsysTurtle);
			else
				featherTurtle.getPosition(feaLsysTurtle,(float)ii/(float)_featherAttrs->_barbuleNum );
			//-------get current turtle


			//-------get turbulence data
			_featherAttrs->_forceRotateScale.getValueAtPosition( ((float)ii/(float)_featherAttrs->_barbuleNum),
																forceRs);
			_featherAttrs->_forceScale.getValueAtPosition( ((float)ii/(float)_featherAttrs->_barbuleNum),
																forceS);
			_featherAttrs->_barbuleUpDownRachis.getValueAtPosition( ((float)ii/(float)_featherAttrs->_barbuleNum),
																updownR);
			_featherAttrs->_barbuleThickAdjust.getValueAtPosition( ((float)ii/(float)_featherAttrs->_barbuleNum),
																thickAdj);
			//-------get turbulence data


			//---------get rotate real angle
			realAngle = _featherAttrs->_keyBarAttrs.getStartAngleAt( ((float)ii/(float)_featherAttrs->_barbuleNum) );
			rotate( lr_n1_1*realAngle,feaLsysTurtle);
			rotateForGap(gapData,left_right,ii,feaLsysTurtle);//rotate to get gaps
			//----------get rotate real angle

			currentForce=0;		barbuleLength=0;		turnPoint = 0;		lastTurn=currentTurn=0;		turnSwitch=true;
			thickRandNoise = noiseRandom(left_right,ii,1,seed+left_right)*_featherAttrs->_barbuleRandThick;
			lengthRandNoise = noiseRandom(left_right,ii,2,seed+left_right)*_featherAttrs->_barbuleLengthRandScale;
			noRandomStep = barMaxLength/(float)(_featherAttrs->_barbuleSegments-1) * barbuleLengthScale;
			uniformWidth = (1-thickRandNoise) * thickAdj;

			singleBarbule.clear();
			barbuleNormal.clear();
			
			for(int jj=0;jj<_featherAttrs->_barbuleSegments;++jj)
			{
				if(jj!=0)
				{
					realStep= noRandomStep * ( 1 - lengthRandNoise );
					move(realStep,feaLsysTurtle);
					barbuleLength += realStep;

					currentTurn = (int)(barbuleLength/noRandomStep);
					if( currentTurn > lastTurn ) {turnPoint++;turnSwitch=true;}
					else turnSwitch=false;
					lastTurn = currentTurn;
				}
				//大形旋转
				if( turnSwitch )
				{
					realAngle = _featherAttrs->_keyBarAttrs.getAngleAt( (float)ii/(float)_featherAttrs->_barbuleNum,(float)turnPoint/(float)_featherAttrs->_barbuleSegments);
					rotate( -realAngle * lr_n1_1,feaLsysTurtle);
				}
				//随机旋转
				forceRandNoise = noiseRandom(left_right,ii,jj,seed+left_right)*_featherAttrs->_forcePerSegment;
				currentForce +=	forceRandNoise*forceS;
				if( currentForce > _featherAttrs->_turnForce )
				{
					rotate( lr_n1_1* -_featherAttrs->_rotateLamda * forceRs * chooseLR((float)ii/(float)_featherAttrs->_barbuleNum,
							(float)jj/(float)_featherAttrs->_barbuleSegments,
							seed+left_right) ,feaLsysTurtle);
					currentForce = 0;
				}
				//上下移动
				updownDegree = barbuleBarUpDownScale[jj] *updownR* _featherAttrs->_upDownLamda ;
				if(_featherAttrs->_upDownNoise)
					updownDegree *= (chooseLR(  (float)ii/(float)_featherAttrs->_barbuleNum,
												(float)jj/(float)_featherAttrs->_barbuleSegments,
												seed+left_right)+1)/2.0f;

				rotateAlongRight(updownDegree,feaLsysTurtle);

				singleBarbule.append(feaLsysTurtle.currentPos);
				barbuleNormal.append(feaLsysTurtle.currentUp);
			}

			#pragma omp critical
			{
				if(left_right==0)
				{
					realFeather.leftBarbules.push_back(singleBarbule);
					realFeather.leftBarbuleRachisPos.append((float)ii/(float)_featherAttrs->_barbuleNum);
					realFeather.leftBarbuleLenPer.append(barbuleLength/barMaxLength);
					realFeather.leftBarbuleWidth.append(uniformWidth);
					realFeather.leftBarbuleNormal.push_back(barbuleNormal);
				}
				else
				{
					realFeather.rightBarbules.push_back(singleBarbule);
					realFeather.rightBarbuleRachisPos.append( (float)ii/(float)_featherAttrs->_barbuleNum + 1 );
					realFeather.rightBarbuleLenPer.append(barbuleLength/barMaxLength);
					realFeather.rightBarbuleWidth.append(uniformWidth);
					realFeather.rightBarbuleNormal.push_back(barbuleNormal);
				}
			}				
			singleBarbule.clear();
			barbuleNormal.clear();
		}
	}//-------left_right
	if(_featherAttrs->_outputFeatherMesh )
		genMeshFromFeather(realFeather);
	//t2=clock();
	//MString info;
	//info +=jcFea_UseMultiThread;
	//info +=" ";
	//info +=jcFea_MaxThreads;
	//info +=" ";
	//info +=(double)(t2-t1);
	//MGlobal::displayInfo(info);

	return true;
}
void featherGenBase::getKeyBarbule(const MObject &inputSurface, singleFeather& oneFeather)
{
		MStatus status=MS::kSuccess;

		MFnNurbsSurface surfaceFn;
		surfaceFn.setObject(inputSurface);
		lsysTurtle feaLsysTurtle;
		MPoint currentPt;

		//rachis
		feaLsysTurtle.lsysInit(_featherAttrs->_rachisPos);
		moveInNurbs(_featherAttrs->_rachisStart,feaLsysTurtle);
		for(int ii=0;ii<_featherAttrs->_rachisSegment;++ii)
		{
			if(ii!=0)
				moveInNurbs( (_featherAttrs->_rachisEnd-_featherAttrs->_rachisStart)/(float)(_featherAttrs->_rachisSegment-1) ,feaLsysTurtle);
			if( _featherAttrs->_direction ==0 )
				surfaceFn.getPointAtParam( feaLsysTurtle.currentPos.x,feaLsysTurtle.currentPos.z,currentPt,MSpace::kWorld );
			else
				surfaceFn.getPointAtParam(feaLsysTurtle.currentPos.z,feaLsysTurtle.currentPos.x,currentPt,MSpace::kWorld);

			oneFeather.rachis.append( MFloatPoint( currentPt));
			oneFeather.proxyBBox.expand(currentPt);
		}
		//getProxyBBFromRachis(oneFeather,1.0,1.0);

		//Barbule
		float walkPerStep=_featherAttrs->_barbuleLength/(float)(_featherAttrs->_barbuleSegments-1);
		MFloatPointArray singleBarbule;
		float realAngle=0;
		float realStep=0,stepScale=0;

		//left------------------------------------------------------------------------------------
		if( (1-_featherAttrs->_rachisPos)<0.00001 )goto rightBarbule;
		for(int ii=0;ii<4;++ii)
		{
			feaLsysTurtle.lsysInit(_featherAttrs->_rachisPos);
			feaLsysTurtle.currentPos.x = _featherAttrs->_keyBarAttrs.barbule[ii];

			rotate( _featherAttrs->_keyBarAttrs.startAngle[ii],feaLsysTurtle );
			singleBarbule.clear();
			_featherAttrs->_rightBarbuleLengthScale.getValueAtPosition(_featherAttrs->_keyBarAttrs.barbule[ii],stepScale);
			for(int jj=0;jj<_featherAttrs->_barbuleSegments;++jj)
			{
				if(jj!=0)
				{
					_featherAttrs->_keyBarAttrs.ramp[ii].getValueAtPosition( (float)jj/(float)_featherAttrs->_barbuleSegments,realAngle);
					rotate( -(realAngle-0.5f)*_featherAttrs->_keyBarAttrs.stepAngle,feaLsysTurtle );
					realStep = walkPerStep*( 1-_featherAttrs->_rachisPos )*stepScale;
					moveInNurbs(realStep,feaLsysTurtle);
				}
				if( _featherAttrs->_direction ==0 )
					surfaceFn.getPointAtParam(feaLsysTurtle.currentPos.x,feaLsysTurtle.currentPos.z,currentPt,MSpace::kWorld);
				else
					surfaceFn.getPointAtParam(feaLsysTurtle.currentPos.z,feaLsysTurtle.currentPos.x,currentPt,MSpace::kWorld);

				singleBarbule.append( MFloatPoint(currentPt));
				oneFeather.proxyBBox.expand(currentPt);
			}
			oneFeather.leftBarbules.push_back(singleBarbule);
		}

		//goto statement
		rightBarbule:
		//right------------------------------------------------------------------------------
		if(_featherAttrs->_rachisPos<0.00001 )goto barbuleEnd;
		for(int ii=0;ii<4;++ii)
		{
			feaLsysTurtle.lsysInit(_featherAttrs->_rachisPos);
			feaLsysTurtle.currentPos.x = _featherAttrs->_keyBarAttrs.barbule[ii];

			rotate( -_featherAttrs->_keyBarAttrs.startAngle[ii],feaLsysTurtle);
			singleBarbule.clear();
			_featherAttrs->_rightBarbuleLengthScale.getValueAtPosition(_featherAttrs->_keyBarAttrs.barbule[ii],stepScale);
			for(int jj=0;jj<_featherAttrs->_barbuleSegments;++jj)
			{
				if(jj!=0)
				{
					_featherAttrs->_keyBarAttrs.ramp[ii].getValueAtPosition( (float)jj/(float)_featherAttrs->_barbuleSegments,realAngle);
					rotate( (realAngle-0.5f)*_featherAttrs->_keyBarAttrs.stepAngle,feaLsysTurtle);
					realStep= walkPerStep*_featherAttrs->_rachisPos*stepScale;
					moveInNurbs(realStep,feaLsysTurtle);
				}
				if( _featherAttrs->_direction ==0 )
					surfaceFn.getPointAtParam(feaLsysTurtle.currentPos.x,feaLsysTurtle.currentPos.z,currentPt,MSpace::kWorld);
				else
					surfaceFn.getPointAtParam(feaLsysTurtle.currentPos.z,feaLsysTurtle.currentPos.x,currentPt,MSpace::kWorld);

				singleBarbule.append( MFloatPoint(currentPt) );
				oneFeather.proxyBBox.expand(currentPt);
			}
			oneFeather.rightBarbules.push_back(singleBarbule);
		}
		//goto statement
		barbuleEnd:;
}
void featherGenBase::getKeyBarbule( turtles& featherTurtle,singleFeather &realFeather )
{
	MStatus status=MS::kSuccess;

	if( _featherAttrs->_barbuleLength<0.00001) return;

	int turtleKeySize= featherTurtle._turtles.size();
	if(turtleKeySize<=0) return;

	if(_featherAttrs->_curveType==1)
	{
		int rachisSample=_featherAttrs->_rachisSegment;
		if(rachisSample<turtleKeySize)rachisSample=turtleKeySize;
		featherTools::getPosNormFromTurtles(featherTurtle,rachisSample,_feaExpInf._renderCurveFuncion,
											realFeather.rachis,realFeather.rachisNormal);
		for(unsigned int jj=0;jj<realFeather.rachis.length()-1;++jj)
			realFeather.rachisLength += (realFeather.rachis[jj+1]-realFeather.rachis[jj]).length();
	}
	else
		featherTurtle.getRachis(realFeather);
	
	
	//------------------------------------
	jcSpline3D posSpline,norSpline;
	if(_featherAttrs->_curveType==1)
	{
		featherTools::getJCSplineTurtlesPos(featherTurtle,posSpline);
		featherTools::getJCSplineTurtlesNor(featherTurtle,norSpline);
	}

	float barMax=0;
	barMax = _featherAttrs->_barbuleLength * realFeather.rachisLength;
	getProxyBBFromRachis(realFeather,featherTurtle._scale,barMax);//得到proxyboudingbox

	MFloatPointArray singleBarbule;
	float noRandomStep=0,barMaxLength=0;
	float realAngle=0,realStep=0,stepScale=0;
	int curSeg=0;
	lsysTurtle lt[4],feaLsysTurtle;
	for(int ii=0;ii<4;++ii)
	{
		curSeg = (int)(_featherAttrs->_keyBarAttrs.barbule[ii] * 100);
		if(_featherAttrs->_curveType==1)
			featherTools::getlsysTurtleFromSpline(_feaExpInf._renderCurveFuncion,curSeg,100,posSpline,norSpline,lt[ii]);
		else
			featherTurtle.getPosition(lt[ii],_featherAttrs->_keyBarAttrs.barbule[ii] );
	}

	//left barbule
	for(int ii=0;ii<4;++ii)
	{
		feaLsysTurtle.assign(lt[ii]);
		rotate( _featherAttrs->_keyBarAttrs.startAngle[ii],feaLsysTurtle );
		singleBarbule.clear();

		_featherAttrs->_leftBarbuleLengthScale.getValueAtPosition(_featherAttrs->_keyBarAttrs.barbule[ii],stepScale);
		barMaxLength = _featherAttrs->_barbuleLength *stepScale*realFeather.rachisLength;
		noRandomStep = barMaxLength/(float)(_featherAttrs->_barbuleSegments-1);
		for(int jj=0;jj<_featherAttrs->_barbuleSegments;++jj)
		{
			if(jj!=0)
			{
				realStep = noRandomStep;
				move(realStep,feaLsysTurtle);
				_featherAttrs->_keyBarAttrs.ramp[ii].getValueAtPosition( (float)jj/(float)_featherAttrs->_barbuleSegments,realAngle);
				rotate( -(realAngle-0.5f)*_featherAttrs->_keyBarAttrs.stepAngle,feaLsysTurtle );
			}
			singleBarbule.append(feaLsysTurtle.currentPos);
		}
		realFeather.leftBarbules.push_back(singleBarbule);
	}

	//right

	for(int ii=0;ii<4;++ii)
	{
		feaLsysTurtle.assign(lt[ii]);

		rotate( -_featherAttrs->_keyBarAttrs.startAngle[ii],feaLsysTurtle );
		singleBarbule.clear();

		_featherAttrs->_rightBarbuleLengthScale.getValueAtPosition(_featherAttrs->_keyBarAttrs.barbule[ii],stepScale);
		barMaxLength = _featherAttrs->_barbuleLength * stepScale*realFeather.rachisLength;
		noRandomStep = barMaxLength/(float)(_featherAttrs->_barbuleSegments-1);
		for(int jj=0;jj<_featherAttrs->_barbuleSegments;++jj)
		{
			if(jj!=0)
			{
				realStep = noRandomStep;
				move(realStep,feaLsysTurtle);
				_featherAttrs->_keyBarAttrs.ramp[ii].getValueAtPosition( (float)jj/(float)_featherAttrs->_barbuleSegments,realAngle);
				rotate( (realAngle-0.5f)*_featherAttrs->_keyBarAttrs.stepAngle,feaLsysTurtle );
			}
			singleBarbule.append(feaLsysTurtle.currentPos);
		}
		realFeather.leftBarbules.push_back(singleBarbule);
	}

}
void featherGenBase::getExKeyBarbule( turtles& featherTurtle,singleFeather &realFeather )
{
	MStatus status=MS::kSuccess;

	if( _featherAttrs->_barbuleLength<0.00001) return;

	int turtleKeySize= featherTurtle._turtles.size();
	if(turtleKeySize<=0) return;

	if(_featherAttrs->_curveType==1)
	{
		int rachisSample=_featherAttrs->_rachisSegment;
		if(rachisSample<turtleKeySize)rachisSample=turtleKeySize;
		featherTools::getPosNormFromTurtles(featherTurtle,rachisSample,_feaExpInf._renderCurveFuncion,
											realFeather.rachis,realFeather.rachisNormal);
	}
	else
		featherTurtle.getRachis(realFeather);
	
	getExProxyBB(featherTurtle,realFeather);

	//------------------------------------
	jcSpline3D posSpline,norSpline,sideSplines[2];
	if(_featherAttrs->_curveType==1)
	{
		featherTools::getJCSplineTurtlesPos(featherTurtle,posSpline);
		featherTools::getJCSplineTurtlesNor(featherTurtle,norSpline);
	}
	featherTools::getJCSplineTurtlesSide(featherTurtle._leftPoints,sideSplines[0]);
	featherTools::getJCSplineTurtlesSide(featherTurtle._rightPoints,sideSplines[1]);	
	//------------------------------------

	MFloatPointArray singleBarbule;
	float noRandomStep=0,sideDist=0;
	float realAngle=0,realStep=0,stepScale=0;
	int curSeg=0;
	lsysTurtle lt[4],feaLsysTurtle;
	MPoint sidePoint;

	for(int ii=0;ii<4;++ii)
	{
		curSeg = (int)(_featherAttrs->_keyBarAttrs.barbule[ii] * 100);
		if(_featherAttrs->_curveType==1)
			featherTools::getlsysTurtleFromSpline(_feaExpInf._renderCurveFuncion,curSeg,100,posSpline,norSpline,lt[ii]);
		else
			featherTurtle.getPosition(lt[ii],_featherAttrs->_keyBarAttrs.barbule[ii] );
	}

	int	  lr_n1_1=0;
	//left barbule
	for(int left_right=0;left_right<2;++left_right)
	{
		lr_n1_1 = 1-left_right*2;

		for(int ii=0;ii<4;++ii)
		{
			feaLsysTurtle.assign(lt[ii]);

			singleBarbule.clear();

			if(!left_right )
				_featherAttrs->_leftBarbuleLengthScale.getValueAtPosition(_featherAttrs->_keyBarAttrs.barbule[ii],stepScale);
			else
				_featherAttrs->_rightBarbuleLengthScale.getValueAtPosition(_featherAttrs->_keyBarAttrs.barbule[ii],stepScale);

			//-------get currentSidePt
			sideSplines[left_right].getValueAt( _feaExpInf._renderCurveFuncion,
												_featherAttrs->_keyBarAttrs.barbule[ii],
												&sidePoint.x,&sidePoint.y,&sidePoint.z);
			sideDist = feaLsysTurtle.currentPos.distanceTo(MFloatPoint(sidePoint));
			if(sideDist<0.00001) continue;
			//-------get currentSidePt

			//---------get rotate real angle
			rotate(sidePoint,feaLsysTurtle);
			//----------get rotate real angle

			noRandomStep = _featherAttrs->_barbuleLength/(float)(_featherAttrs->_barbuleSegments-1)*stepScale*sideDist;
			for(int jj=0;jj<_featherAttrs->_barbuleSegments;++jj)
			{
				if(jj!=0)
				{
					realStep = noRandomStep;
					move(realStep,feaLsysTurtle);
					_featherAttrs->_keyBarAttrs.ramp[ii].getValueAtPosition( (float)jj/(float)_featherAttrs->_barbuleSegments,realAngle);
					rotate( -lr_n1_1*(realAngle-0.5f)*_featherAttrs->_keyBarAttrs.stepAngle,feaLsysTurtle );
				}
				singleBarbule.append(feaLsysTurtle.currentPos);
			}
			if(!left_right )
				realFeather.leftBarbules.push_back(singleBarbule);
			else
				realFeather.rightBarbules.push_back(singleBarbule);
		}
	}
}
void featherGenBase::getTurtles( const MObject &inputSurface,turtles * result)
{
	MStatus status=MS::kSuccess;

	result->clearKeyTurtle();

	MFnNurbsSurface surfaceFn;
	surfaceFn.setObject(inputSurface);

	MPoint currentPt;
	MVector currentNormal,currentLeft,currentFoward;
	keyTurtle tempTurtle;
	lsysTurtle feaLsysTurtle;
	feaLsysTurtle.lsysInit(_featherAttrs->_rachisPos);

	float ranchiLen = _featherAttrs->_rachisEnd - _featherAttrs->_rachisStart;
	feaLsysTurtle.currentPos.x = _featherAttrs->_rachisStart;

	//将引导面的轮廓记录下来。记录内容包括，中轴点的位置，以及该点的法线
	for( int ii=0;ii<_featherAttrs->_rachisSegment;++ii )
	{
		if(ii!=0)
			moveInNurbs( ranchiLen * 1.0f/(float)(_featherAttrs->_rachisSegment-1),feaLsysTurtle );
		if( _featherAttrs->_direction ==0 )
		{
			surfaceFn.getPointAtParam( feaLsysTurtle.currentPos.x,feaLsysTurtle.currentPos.z,currentPt,MSpace::kWorld );
			currentNormal = surfaceFn.normal(feaLsysTurtle.currentPos.x,feaLsysTurtle.currentPos.z,MSpace::kWorld,&status);
		}
		else
		{
			surfaceFn.getPointAtParam( feaLsysTurtle.currentPos.z,feaLsysTurtle.currentPos.x,currentPt,MSpace::kWorld );
			currentNormal = surfaceFn.normal( feaLsysTurtle.currentPos.z,feaLsysTurtle.currentPos.x,MSpace::kWorld,&status );
		}

		tempTurtle.currentPos = MFloatPoint( currentPt );
		tempTurtle.currentUp = MFloatVector( currentNormal );

		result->addKeyTurtle(tempTurtle);
	}
}
void featherGenBase::getExProxyBB(const turtles& featherTurtle,singleFeather &feather)
{
	for(int ii=0;ii<featherTurtle._leftPoints.length();++ii)
		feather.proxyBBox.expand(featherTurtle._leftPoints[ii]);
	for(int ii=0;ii<featherTurtle._rightPoints.length();++ii)
		feather.proxyBBox.expand(featherTurtle._rightPoints[ii]);
	getProxyBBFromRachis(feather,1,0);
}
void featherGenBase::getProxyBBFromRachis(singleFeather &feather,float scale,float barLenScale)
{
	MFloatVector fowDir,rightDir;
	MFloatPoint tempPt;
	int size = feather.rachis.length();
	for(int ii=0;ii<size;++ii)
	{
		if(ii<size-1)
			fowDir = feather.rachis[ii+1]-feather.rachis[ii];
		else
			fowDir = feather.rachis[ii]-feather.rachis[ii-1];

		rightDir = (fowDir^feather.rachisNormal[ii]).normal();

		tempPt = feather.rachis[ii];
		feather.proxyBBox.expand(tempPt);
		feather.proxyBBox.expand(tempPt+rightDir * ( _featherAttrs->_proxyBoundingBoxScale[0]+barLenScale)*scale);
		feather.proxyBBox.expand(tempPt-rightDir * ( _featherAttrs->_proxyBoundingBoxScale[0]+barLenScale)*scale);
		feather.proxyBBox.expand(tempPt+feather.rachisNormal[ii] * _featherAttrs->_proxyBoundingBoxScale[2]*scale);
		feather.proxyBBox.expand(tempPt-feather.rachisNormal[ii] * _featherAttrs->_proxyBoundingBoxScale[2]*scale);

		if(ii==0)
		{
			tempPt = feather.rachis[ii]-fowDir * _featherAttrs->_proxyBoundingBoxScale[1]*scale;
			feather.proxyBBox.expand(tempPt);
			feather.proxyBBox.expand(tempPt+rightDir * ( _featherAttrs->_proxyBoundingBoxScale[0]+barLenScale)*scale);
			feather.proxyBBox.expand(tempPt-rightDir * ( _featherAttrs->_proxyBoundingBoxScale[0]+barLenScale)*scale);
			feather.proxyBBox.expand(tempPt+feather.rachisNormal[ii]*_featherAttrs->_proxyBoundingBoxScale[2]*scale);
			feather.proxyBBox.expand(tempPt-feather.rachisNormal[ii]*_featherAttrs->_proxyBoundingBoxScale[2]*scale);

		}
		if(ii==size-1)
		{
			tempPt = feather.rachis[ii]+fowDir * _featherAttrs->_proxyBoundingBoxScale[1]*scale;
			feather.proxyBBox.expand(tempPt);
			feather.proxyBBox.expand(tempPt+rightDir * ( _featherAttrs->_proxyBoundingBoxScale[0]+barLenScale)*scale);
			feather.proxyBBox.expand(tempPt-rightDir * ( _featherAttrs->_proxyBoundingBoxScale[0]+barLenScale)*scale);
			feather.proxyBBox.expand(tempPt+feather.rachisNormal[ii]*_featherAttrs->_proxyBoundingBoxScale[2]*scale);
			feather.proxyBBox.expand(tempPt-feather.rachisNormal[ii]*_featherAttrs->_proxyBoundingBoxScale[2]*scale);
		}
	}
}

void featherGenBase::rotate(float degree,lsysTurtle &curTurtle)
{
	MVector turtleDir = MVector(curTurtle.currentDir.x,curTurtle.currentDir.y,curTurtle.currentDir.z);
	MVector curDir = turtleDir.rotateBy(MQuaternion(degree * jerryC::radians_per_degree,MVector(curTurtle.currentUp)));

	curTurtle.currentDir.x = (float)curDir.x;
	curTurtle.currentDir.y = (float)curDir.y;
	curTurtle.currentDir.z = (float)curDir.z;
}
void featherGenBase::rotate(MPoint pt,lsysTurtle &curTurtle)
{
	MQuaternion sideDir = MVector(curTurtle.currentDir).rotateTo( pt-(MPoint)curTurtle.currentPos );
	curTurtle.currentDir = (MFloatPoint)pt-curTurtle.currentPos;
	curTurtle.currentUp = MFloatVector(MVector(curTurtle.currentUp).rotateBy(sideDir));
}
void featherGenBase::moveInNurbs(float length,lsysTurtle &curTurtle)
{
	curTurtle.currentPos += length * curTurtle.currentDir;
	curTurtle.currentPos.x = clamp0_1(curTurtle.currentPos.x);
	curTurtle.currentPos.z = clamp0_1(curTurtle.currentPos.z);
}
void featherGenBase::move(float length,lsysTurtle &curTurtle)
{
	curTurtle.currentPos += length * curTurtle.currentDir;
}
void featherGenBase::rotateAlongRight(float degree,lsysTurtle &curTurtle)//turtle上下旋转
{
	MVector right= MVector(curTurtle.currentDir)^MVector(curTurtle.currentUp);

	MVector tempvv = MVector(curTurtle.currentDir.x,curTurtle.currentDir.y,curTurtle.currentDir.z);
	MVector tempV = tempvv.rotateBy(MQuaternion(degree * jerryC::radians_per_degree,right));

	curTurtle.currentDir.x = (float)tempV.x;
	curTurtle.currentDir.y = (float)tempV.y;
	curTurtle.currentDir.z = (float)tempV.z;

	tempvv = MVector(curTurtle.currentUp.x,curTurtle.currentUp.y,curTurtle.currentUp.z);
	tempV = tempvv.rotateBy(MQuaternion(degree * jerryC::radians_per_degree,right));

	curTurtle.currentUp.x = (float)tempV.x;
	curTurtle.currentUp.y = (float)tempV.y;
	curTurtle.currentUp.z = (float)tempV.z;
}

//----
float featherGenBase::chooseLR(float u,float v,int seed)//u as the rachis u value ,v as the current barbuleLength
{
	return (float)jerryC::ValueCoherentNoise3D((double)(u*_featherAttrs->_rachisNoiseFrequency)+_featherAttrs->_noisePhase[0],
												0,
												(double)(v*_featherAttrs->_barbuleNoiseFrequency)+_featherAttrs->_noisePhase[1],
												_featherAttrs->_randSeed+seed,
												1);
}
float featherGenBase::noiseRandom(int x,int y,int z,int seed)
{
	return (float)(jerryC::ValueNoise3D(x,y,z,_featherAttrs->_randSeed+seed)+1.0)/2.0;
}
void featherGenBase::computeGapData(barbuleGapData &gapData,int left_right,int seed)
{
	gapData.clear();
	if(_featherAttrs->_gapForce[left_right]>0 && _featherAttrs->_gapSize[left_right]>0)
	{
		float gapForce=0;
		float tempRampV=0;

		for(int ii=0;ii<=_featherAttrs->_barbuleNum;++ii)
		{
			_featherAttrs->_gapDensity[left_right].getValueAtPosition((float)ii/(float)_featherAttrs->_barbuleNum,tempRampV);
			gapForce += noiseRandom(left_right,ii,0,seed+left_right+21) *
						_featherAttrs->_gapForce[left_right]*
						tempRampV;
			if(gapForce >= _featherAttrs->_gapMaxForce[left_right])
			{
				gapData._gapForce.push_back(gapForce);
				gapData._gapPosition.push_back(ii);
				gapForce = 0;
			}
		}
	}
}
void featherGenBase::rotateForGap(const barbuleGapData &gapData,int left_right,int pos,lsysTurtle &curTurtle)
{
	int gapNum=(int)gapData._gapPosition.size();
	if(gapNum<=0) return;

	if( pos <= gapData._gapPosition[0] )
		rotate( (1-left_right*2) * _featherAttrs->_gapSize[left_right] * gapData._gapForce[0] * pos/gapData._gapPosition[0], 
				curTurtle );
	else
	{
		for(int ii=1;ii<gapNum;++ii)
			if( pos>gapData._gapPosition[ii-1] && pos<=gapData._gapPosition[ii] )
				rotate( (1-left_right*2) * _featherAttrs->_gapSize[left_right] * gapData._gapForce[ii] * (pos-gapData._gapPosition[ii-1])/(gapData._gapPosition[ii]-gapData._gapPosition[ii-1]), 
						curTurtle );
	}
}

//------compute mesh for feather
void featherGenBase::adjCrossSec( const MPoint& pt,const MVector& fwd ,float thickScale,MFloatPointArray& pta)
{
	MQuaternion quat = MVector(0,1,0).rotateTo( fwd );  //get the quaternion of vector up to vector fwd

	float angleStep = 2.0f*jerryC::pi/_featherAttrs->_rachisSides;
	float w = _featherAttrs->_rachisThick * thickScale;
	int ix;
	MPoint flpt;
    for ( ix= 0; ix < _featherAttrs->_rachisSides; ix++ ) {
		float angle= ix * angleStep;
		float x = w * sin( angle );
		float z = w * cos( angle );

		flpt = pt + MVector(x,0,z).rotateBy(quat);
		pta.append((float)flpt.x,(float)flpt.y,(float)flpt.z);
	}
}
void featherGenBase::addCylinder(singleFeather& oneFeather)
{
	MFloatPoint pt1;
	MVector dir;
	unsigned int len=oneFeather.rachis.length();
	oneFeather.rachisCylinder.init();
	for(unsigned int ii=0;ii<len;++ii)
	{
		pt1 = oneFeather.rachis[ii];

		if( ii != len-1 )
			dir = oneFeather.rachis[ii+1] - pt1;
		else
			dir = oneFeather.rachis[len-1] - oneFeather.rachis[len-2];

		adjCrossSec(pt1,dir,oneFeather.rachisWidth[ii],oneFeather.rachisCylinder.pa);

		for(int jj=0;jj<=_featherAttrs->_rachisSides;++jj)
		{
			oneFeather.rachisCylinder.ua.append( (float)jj/(float)(_featherAttrs->_rachisSides) );
			oneFeather.rachisCylinder.va.append( (float)ii/(float)(len-1) );
		}

	}
	for(unsigned int ii=0;ii<oneFeather.rachisCylinder.pa.length();++ii)
		oneFeather.rachisMeshBBox.expand(oneFeather.rachisCylinder.pa[ii]);

	for(unsigned int ii=0;ii<len-1;++ii)
		for(int jj=0;jj<_featherAttrs->_rachisSides;++jj)
		{
			oneFeather.rachisCylinder.faceCounts.append(4);
			oneFeather.rachisCylinder.faceConnects.append(_featherAttrs->_rachisSides*ii+jj);

			if((jj+1)==_featherAttrs->_rachisSides)
			{
				oneFeather.rachisCylinder.faceConnects.append(_featherAttrs->_rachisSides*ii);
				oneFeather.rachisCylinder.faceConnects.append((ii+1)*_featherAttrs->_rachisSides);
			}
			else
			{
				oneFeather.rachisCylinder.faceConnects.append(_featherAttrs->_rachisSides*ii+jj+1);
				oneFeather.rachisCylinder.faceConnects.append( (ii+1)*_featherAttrs->_rachisSides +jj +1 );
			}

			oneFeather.rachisCylinder.faceConnects.append( (ii+1)*_featherAttrs->_rachisSides +jj );

			oneFeather.rachisCylinder.uvids.append( (_featherAttrs->_rachisSides+1)*ii+jj );
			oneFeather.rachisCylinder.uvids.append( (_featherAttrs->_rachisSides+1)*ii+jj+1 );
			oneFeather.rachisCylinder.uvids.append( (ii+1)*(_featherAttrs->_rachisSides+1) +jj + 1 );
			oneFeather.rachisCylinder.uvids.append( (ii+1)*(_featherAttrs->_rachisSides+1) +jj  );
		}
}
void featherGenBase::addBarbuleFacePoint( polyObj& mesh,float uValue,float vValue,float vWidth,float width,int left_right,lsysTurtle &curTurtle)
{
	MFloatVector leftDir = curTurtle.currentUp^curTurtle.currentDir;
	uValue *= _featherAttrs->_meshUVScale[0];
	vWidth *= _featherAttrs->_meshUVScale[1];
	
	mesh.pa.append( curTurtle.currentPos - left_right*leftDir *width/2 );
	mesh.pa.append( curTurtle.currentPos + left_right*leftDir *width/2 );

	if(left_right==1)
	{
		mesh.ua.append(0.5-uValue/2);
		mesh.ua.append(0.5-uValue/2);
	}
	else
	{
		mesh.ua.append(0.5+uValue/2);
		mesh.ua.append(0.5+uValue/2);
	}

	mesh.va.append(vValue+vWidth);
	mesh.va.append(vValue-vWidth);
}
void featherGenBase::makeBarbuleFace( polyObj& mesh )
{
	unsigned int seg = mesh.pa.length()/2;
	for(unsigned int ii=0;ii<seg-1;++ii)
	{
		mesh.faceCounts.append(4);

		mesh.faceConnects.append(ii*2);
		mesh.faceConnects.append(ii*2+1);
		mesh.faceConnects.append(ii*2+3);
		mesh.faceConnects.append(ii*2+2);

		mesh.uvids.append(ii*2);
		mesh.uvids.append(ii*2+1);
		mesh.uvids.append(ii*2+3);
		mesh.uvids.append(ii*2+2);
	}
}